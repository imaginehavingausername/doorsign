<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Message + Christmas Countdown (fade loop)</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="stage" id="stage">
    <!-- FRONT: message.html loaded here -->
    <div class="screen screen-front visible" id="screen-front" aria-live="polite">
      <div class="content" id="front-content">Loading messageâ€¦</div>
    </div>

    <!-- BACK: Christmas countdown (bigger, centered) -->
    <div class="screen screen-back" id="screen-back" aria-hidden="true">
      <div class="countdown-wrap" id="countdown-wrap">
        <div class="countdown-title">Christmas In</div>
        <div class="countdown-row">
          <div class="time-box"><span id="days">0</span><span class="label">Days</span></div>
          <div class="time-box"><span id="hours">00</span><span class="label">Hours</span></div>
          <div class="time-box"><span id="minutes">00</span><span class="label">Mins</span></div>
          <div class="time-box"><span id="seconds">00</span><span class="label">Secs</span></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* -------------------------
  Configuration
--------------------------*/
const MESSAGE_FETCH_INTERVAL_MS = 30000; // fetch message.html every 30s
const VISIBLE_MS = 5000;                 // how long each screen stays visible
const FADE_MS = 800;                     // fade duration (must match CSS var --fade)
document.documentElement.style.setProperty('--fade', `${FADE_MS}ms`);

/* -------------------------
  Fetch and inject message.html (no-cache so updates appear)
--------------------------*/
async function fetchMessage() {
  try {
    const res = await fetch('message.html', { cache: 'no-store' });
    if (!res.ok) throw new Error('Fetch failed');
    const html = await res.text();
    document.getElementById('front-content').innerHTML = html;
  } catch (err) {
    console.warn('Could not load message.html:', err);
  }
}

/* -------------------------
  Countdown logic (Christmas)
--------------------------*/
function startCountdown() {
  const daysEl = document.getElementById('days');
  const hoursEl = document.getElementById('hours');
  const minsEl = document.getElementById('minutes');
  const secsEl = document.getElementById('seconds');

  function update() {
    const now = new Date();
    let target = new Date(`December 25, ${now.getFullYear()} 00:00:00`);
    if (now > target) target = new Date(`December 25, ${now.getFullYear() + 1} 00:00:00`);
    const totalSeconds = Math.max(0, Math.floor((target - now) / 1000));
    const days = Math.floor(totalSeconds / 86400);
    const hours = Math.floor((totalSeconds % 86400) / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    daysEl.textContent = days;
    hoursEl.textContent = String(hours).padStart(2, '0');
    minsEl.textContent = String(minutes).padStart(2, '0');
    secsEl.textContent = String(seconds).padStart(2, '0');
  }

  update();
  setInterval(update, 1000);
}

/* -------------------------
  Fade orchestration loop
--------------------------*/
function showFront() {
  document.getElementById('screen-front').classList.add('visible');
  document.getElementById('screen-front').setAttribute('aria-hidden','false');
  document.getElementById('screen-back').classList.remove('visible');
  document.getElementById('screen-back').setAttribute('aria-hidden','true');
}

function showBack() {
  document.getElementById('screen-back').classList.add('visible');
  document.getElementById('screen-back').setAttribute('aria-hidden','false');
  document.getElementById('screen-front').classList.remove('visible');
  document.getElementById('screen-front').setAttribute('aria-hidden','true');
}

async function runLoop() {
  // initial fetch & start countdown
  await fetchMessage();
  startCountdown();
  // refresh message every MESSAGE_FETCH_INTERVAL_MS
  setInterval(fetchMessage, MESSAGE_FETCH_INTERVAL_MS);

  // ensure initial state is front visible
  showFront();

  // loop forever: front -> fade -> back -> fade -> repeat
  while (true) {
    await new Promise(r => setTimeout(r, VISIBLE_MS)); // front visible
    showBack();                                       // fade to back (CSS handles transition)
    await new Promise(r => setTimeout(r, VISIBLE_MS + FADE_MS)); // wait for fade + back visible
    showFront();                                      // fade back to front
    await new Promise(r => setTimeout(r, VISIBLE_MS + FADE_MS)); // wait before next flip
  }
}

/* start everything */
runLoop();
</script>
</body>
</html>
